<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Motor 3D - Mode7 Optimizado</title>
  <style>
    body { margin: 0; overflow: hidden; background: #333; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="glCanvas" width="960" height="540"></canvas>
<script src="image64.js"></script>
<script>
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');

// ======= Configuración =======
const TILE_SIZE = 32;
const MAP_WIDTH = 16;
const MAP_HEIGHT = 16;
let billboard_tiles = [4,3];
let block_tiles = [5];
const billboard_tiles_set = new Set(billboard_tiles);
const block_tiles_set = new Set(block_tiles);

// Definir altura de cada tipo de tile (por defecto 1)
const tile_heights = {
  5: 30,  // El tile 5 tendrá 3 bloques de altura
  1: 1,  // Los demás tiles con altura 1 por defecto
  2: 1,
  3: 1,
  4: 1
};

let tile_items_size = 6;

let image = new Image();
const spriteTexture = gl.createTexture();

const tileMapTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tileMapTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

function updateTileMapTexture() {
  const data = new Uint8Array(MAP_WIDTH * MAP_HEIGHT);
  for (let i = 0; i < tileMap.length; i++) {
    data[i] = tileMap[i];
  }
  gl.bindTexture(gl.TEXTURE_2D, tileMapTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8UI, MAP_WIDTH, MAP_HEIGHT, 0, gl.RED_INTEGER, gl.UNSIGNED_BYTE, data);
}

image.onload = function() {
  tile_items_size = Math.floor(image.width / TILE_SIZE);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.bindTexture(gl.TEXTURE_2D, spriteTexture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  
  updateTileMapTexture();
};

image.src = image_64;

// Colores del cielo (RGB normalizado 0-1)
let color1 = [0.5, 0.7, 1.0];  // Color inferior (azul claro)
let color2 = [0.1, 0.3, 0.8];  // Color superior (azul oscuro)

let tileMap = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
  1,2,1,1,2,3,4,3,3,3,3,3,3,3,2,3,
  3,2,3,4,3,3,5,5,3,3,3,3,3,3,2,3,
  3,2,3,3,3,3,3,5,3,3,3,3,3,3,2,3,
  3,2,3,3,3,3,3,3,3,3,3,4,3,3,2,3,
  3,2,3,3,5,3,3,3,1,1,1,1,1,1,2,1,
  1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
];

let camera = {
  x: 8.0,
  y: 4.76,
  z: 1.0,
  angle: 3.0
};

// ======= SHADER CIELO =======
const skyVS = `#version 300 es
in vec2 a_position;
out vec2 v_texCoord;
void main() {
  v_texCoord = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const skyFS = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform vec3 u_color1;
uniform vec3 u_color2;

void main() {
  float t = v_texCoord.y;
  outColor = vec4(mix(u_color1, u_color2, t), 1.0);
}
`;

// ======= SHADER SUELO MODE7 =======
const vsSource = `#version 300 es
in vec2 a_position;
out vec2 v_texCoord;
void main() {
  v_texCoord = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fsSource = `#version 300 es
precision highp float;
in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_spritesheet;
uniform vec4 u_camera;
uniform float u_spriteCount;
uniform int u_tileMap[${MAP_WIDTH * MAP_HEIGHT}];


void main() {
  float angle = u_camera.w;
  float cosA = cos(angle);
  float sinA = sin(angle);

  
  float horizon = 0.3;
  float screenY = 1.0 - v_texCoord.y;
  float perspective = u_camera.z / (screenY - horizon);


  if (perspective < 0.0 || perspective > 500.0) {
    discard;
  }

  float dx = (v_texCoord.x - 0.5);
  float worldX = u_camera.x + (cosA * dx - sinA * 1.0) * perspective;
  float worldY = u_camera.y + (sinA * dx + cosA * 1.0) * perspective;

  int tileX = int(floor(worldX));
  int tileY = int(floor(worldY));

  if(tileX < 0 || tileY < 0 || tileX >= ${MAP_WIDTH} || tileY >= ${MAP_HEIGHT}) {
    discard;
  }

  int tileIndex = u_tileMap[tileY * ${MAP_WIDTH} + tileX];
  if(tileIndex == 0) {
    outColor = vec4(0.3, 0.3, 0.3, 1.0);
    return;
  }

  float tx = fract(worldX);
  float ty = fract(worldY);

  float spriteWidth = 1.0 / u_spriteCount;
  vec2 texCoord = vec2(tx * spriteWidth, ty);
  texCoord.x += float(tileIndex - 1) * spriteWidth;

  outColor = texture(u_spritesheet, texCoord);
}
`;

// ======= SHADER BILLBOARDS =======
const billboardVS = `#version 300 es
in vec2 a_offset;
uniform vec2 u_screenPos;
uniform float u_size;
out vec2 v_texCoord;
void main() {
  vec2 pos = u_screenPos + vec2(a_offset.x, a_offset.y + 1.0) * u_size;
  gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);
  v_texCoord = (a_offset + 1.0) * 0.5;
}
`;

const billboardFS = `#version 300 es
precision highp float;
in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_spritesheet;
uniform int u_spriteIndex;
uniform float u_spriteCount;

void main() {
  vec2 uv = v_texCoord;
  uv.x /= u_spriteCount;
  uv.x += float(u_spriteIndex - 1) / u_spriteCount;

  vec4 color = texture(u_spritesheet, uv);
  if (color.a < 0.1) discard;
  outColor = color;
}
`;

// ======= SHADER BLOQUES 3D CON INSTANCING =======
const blockVS = `#version 300 es
in vec3 a_position;
in vec2 a_texCoord;
in vec4 a_instanceData; // x, y, z, height

uniform vec4 u_camera;
uniform vec2 u_resolution;

out vec2 v_texCoord;
out float v_depth;
out float v_height;

void main() {
  vec3 instancePos = a_instanceData.xyz;
  float height = a_instanceData.w;
  
  // Escalar la posición Y según la altura
  vec3 scaledPos = a_position;
  scaledPos.y *= height;
  
  vec3 worldPos = scaledPos + instancePos;
  
  float dx = worldPos.x - u_camera.x;
  float dy = worldPos.z - u_camera.y;
  
  float angle = u_camera.w;
  float cosA = cos(-angle);
  float sinA = sin(-angle);
  
  float rotX = dx * cosA - dy * sinA;
  float rotY = dx * sinA + dy * cosA;
  
  if (rotY < 0.1) {
    gl_Position = vec4(0.0, 0.0, -2.0, 1.0);
    v_texCoord = a_texCoord;
    v_depth = -1.0;
    v_height = height;
    return;
  }
  
  float horizon = 0.3;
  float screenX = 0.5 + rotX / rotY;
  float screenY = 1.0 - (horizon + (u_camera.z - worldPos.y) / rotY);
  
  gl_Position = vec4(
    screenX * 2.0 - 1.0,
    screenY * 2.0 - 1.0,
    rotY / 50.0,
    1.0
  );
  
  // Repetir textura verticalmente según la altura
  v_texCoord = vec2(a_texCoord.x, a_texCoord.y * height);
  v_depth = rotY;
  v_height = height;
}
`;

const blockFS = `#version 300 es
precision highp float;
in vec2 v_texCoord;
in float v_depth;
in float v_height;
out vec4 outColor;

uniform sampler2D u_spritesheet;
uniform int u_spriteIndex;
uniform float u_spriteCount;

void main() {
  if (v_depth < 0.0) discard;
  
  float spriteWidth = 1.0 / u_spriteCount;
  
  // Usar fract para repetir la textura verticalmente
  vec2 uv = vec2(v_texCoord.x * spriteWidth, fract(v_texCoord.y));
  uv.x += float(u_spriteIndex - 1) * spriteWidth;

  vec4 color = texture(u_spritesheet, uv);
  if (color.a < 0.1) discard;
  outColor = color;
}
`;

// ======= GEOMETRÍA CUBO =======
const cubeVertices = new Float32Array([
  -0.5, 0.0,  0.5,  0, 0,
   0.5, 0.0,  0.5,  1, 0,
   0.5, 1.0,  0.5,  1, 1,
  -0.5, 0.0,  0.5,  0, 0,
   0.5, 1.0,  0.5,  1, 1,
  -0.5, 1.0,  0.5,  0, 1,

   0.5, 0.0, -0.5,  0, 0,
  -0.5, 0.0, -0.5,  1, 0,
  -0.5, 1.0, -0.5,  1, 1,
   0.5, 0.0, -0.5,  0, 0,
  -0.5, 1.0, -0.5,  1, 1,
   0.5, 1.0, -0.5,  0, 1,

  -0.5, 0.0, -0.5,  0, 0,
  -0.5, 0.0,  0.5,  1, 0,
  -0.5, 1.0,  0.5,  1, 1,
  -0.5, 0.0, -0.5,  0, 0,
  -0.5, 1.0,  0.5,  1, 1,
  -0.5, 1.0, -0.5,  0, 1,

   0.5, 0.0,  0.5,  0, 0,
   0.5, 0.0, -0.5,  1, 0,
   0.5, 1.0, -0.5,  1, 1,
   0.5, 0.0,  0.5,  0, 0,
   0.5, 1.0, -0.5,  1, 1,
   0.5, 1.0,  0.5,  0, 1,

  -0.5, 1.0,  0.5,  0, 0,
   0.5, 1.0,  0.5,  1, 0,
   0.5, 1.0, -0.5,  1, 1,
  -0.5, 1.0,  0.5,  0, 0,
   0.5, 1.0, -0.5,  1, 1,
  -0.5, 1.0, -0.5,  0, 1,

  -0.5, 0.0, -0.5,  0, 0,
   0.5, 0.0, -0.5,  1, 0,
   0.5, 0.0,  0.5,  1, 1,
  -0.5, 0.0, -0.5,  0, 0,
   0.5, 0.0,  0.5,  1, 1,
  -0.5, 0.0,  0.5,  0, 1
]);

// ======= COMPILACIÓN SHADERS =======
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader error:', gl.getShaderInfoLog(shader));
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program error:', gl.getProgramInfoLog(program));
    throw new Error(gl.getProgramInfoLog(program));
  }
  return program;
}

const program = createProgram(gl, vsSource, fsSource);
const billboardProgram = createProgram(gl, billboardVS, billboardFS);
const blockProgram = createProgram(gl, blockVS, blockFS);
const skyProgram = createProgram(gl, skyVS, skyFS);

// ======= CACHEAR UNIFORMS Y ATRIBUTOS =======
const uniformLocations = {
  ground: {
    spriteCount: gl.getUniformLocation(program, 'u_spriteCount'),
    camera: gl.getUniformLocation(program, 'u_camera'),
    tileMap: gl.getUniformLocation(program, 'u_tileMap[0]'),
    spritesheet: gl.getUniformLocation(program, 'u_spritesheet')
  },
  billboard: {
    screenPos: gl.getUniformLocation(billboardProgram, 'u_screenPos'),
    size: gl.getUniformLocation(billboardProgram, 'u_size'),
    spriteIndex: gl.getUniformLocation(billboardProgram, 'u_spriteIndex'),
    spriteCount: gl.getUniformLocation(billboardProgram, 'u_spriteCount'),
    spritesheet: gl.getUniformLocation(billboardProgram, 'u_spritesheet')
  },
  block: {
    camera: gl.getUniformLocation(blockProgram, 'u_camera'),
    resolution: gl.getUniformLocation(blockProgram, 'u_resolution'),
    spriteIndex: gl.getUniformLocation(blockProgram, 'u_spriteIndex'),
    spriteCount: gl.getUniformLocation(blockProgram, 'u_spriteCount'),
    spritesheet: gl.getUniformLocation(blockProgram, 'u_spritesheet')
  },
  sky: {
    color1: gl.getUniformLocation(skyProgram, 'u_color1'),
    color2: gl.getUniformLocation(skyProgram, 'u_color2')
  }
};

const attribLocations = {
  ground: {
    position: gl.getAttribLocation(program, 'a_position')
  },
  billboard: {
    offset: gl.getAttribLocation(billboardProgram, 'a_offset')
  },
  block: {
    position: gl.getAttribLocation(blockProgram, 'a_position'),
    texCoord: gl.getAttribLocation(blockProgram, 'a_texCoord'),
    instanceData: gl.getAttribLocation(blockProgram, 'a_instanceData')
  },
  sky: {
    position: gl.getAttribLocation(skyProgram, 'a_position')
  }
};

// ======= BUFFERS =======
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

const billboardBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, billboardBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

const cubeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

const instanceBuffer = gl.createBuffer();

const skyBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, skyBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

// ======= FRUSTUM CULLING OPTIMIZADO =======
function isInFrustum(worldX, worldZ) {
  const dx = worldX - camera.x;
  const dz = worldZ - camera.y;
  
  const cosA = Math.cos(-camera.angle);
  const sinA = Math.sin(-camera.angle);
  
  const rotY = dx * sinA + dz * cosA;
  
  if (rotY < 0.1 || rotY > 30.0) return false;
  
  const rotX = dx * cosA - dz * sinA;
  const screenX = 0.5 + rotX / rotY;
  
  return screenX >= -0.2 && screenX <= 1.2;
}

// ======= RECOLECTAR OBJETOS CON ALGORITMO DEL PINTOR =======
function collectRenderableObjects() {
  const allObjects = [];
  
  for (let i = 0; i < tileMap.length; i++) {
    const tile = tileMap[i];
    if (tile === 0) continue;
    
    const mapX = i % MAP_WIDTH;
    const mapY = Math.floor(i / MAP_WIDTH);
    
    const worldX = mapX + 0.5;
    const worldZ = mapY + 0.5;
    
    if (!isInFrustum(worldX, worldZ)) continue;
    
    const dx = worldX - camera.x;
    const dz = worldZ - camera.y;
    const dist = dx * dx + dz * dz;
    
    if (isBillboard(tile)) {
      const proj = projectToScreen(worldX, worldZ);
      if (proj.visible) {
        allObjects.push({
          type: 'billboard',
          x: worldX, 
          y: worldZ, 
          tile, 
          dist, 
          proj
        });
      }
    } else if (isBlock(tile)) {
      allObjects.push({
        type: 'block',
        x: worldX,
        y: 0.0,
        z: worldZ,
        tile,
        dist
      });
    }
  }
  
  allObjects.sort((a, b) => b.dist - a.dist);
  
  return allObjects;
}

let sky_colors = true;

// ======= RENDER =======
function render(time) {
  updateCamera();
  
  gl.viewport(0, 0, canvas.width, canvas.height);
  
  // Cielo
  if (sky_colors){
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);

    gl.useProgram(skyProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, skyBuffer);
    gl.enableVertexAttribArray(attribLocations.sky.position);
    gl.vertexAttribPointer(attribLocations.sky.position, 2, gl.FLOAT, false, 0, 0);

    gl.uniform3f(uniformLocations.sky.color1, color1[0], color1[1], color1[2]);
    gl.uniform3f(uniformLocations.sky.color2, color2[0], color2[1], color2[2]);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  
  // 1. Suelo
  gl.disable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  
  gl.useProgram(program);
  
  gl.enableVertexAttribArray(attribLocations.ground.position);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(attribLocations.ground.position, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1f(uniformLocations.ground.spriteCount, tile_items_size);
  gl.uniform4f(uniformLocations.ground.camera, camera.x, camera.y, camera.z, camera.angle);
  gl.uniform1iv(uniformLocations.ground.tileMap, tileMap);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, spriteTexture);
  gl.uniform1i(uniformLocations.ground.spritesheet, 0);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  const allObjects = collectRenderableObjects();

  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.depthMask(true);
  gl.disable(gl.BLEND);

  let currentTile = null;
  let batchInstances = [];

  for (const obj of allObjects) {
    if (obj.type === 'block') {
      if (currentTile === null) {
        currentTile = obj.tile;
      }

      if (currentTile === obj.tile) {
        batchInstances.push(obj);
      } else {
        if (batchInstances.length > 0) {
          drawBlocksInstanced(currentTile, batchInstances);
        }
        currentTile = obj.tile;
        batchInstances = [obj];
      }
    } else if (obj.type === 'billboard') {
      if (batchInstances.length > 0) {
        drawBlocksInstanced(currentTile, batchInstances);
        batchInstances = [];
        currentTile = null;
      }
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(false);

      drawBillboard(obj);

      gl.depthMask(true);
      gl.disable(gl.BLEND);
    }
  }

  if (batchInstances.length > 0) {
    drawBlocksInstanced(currentTile, batchInstances);
  }

  gl.disable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);

  requestAnimationFrame(render);
}

function drawBlocksInstanced(tileType, instances) {
  if (!instances || instances.length === 0) return;
  
  gl.useProgram(blockProgram);
  
  // Obtener la altura para este tipo de tile
  const height = tile_heights[tileType] || 1;
  
  // Ahora necesitamos 4 floats por instancia: x, y, z, height
  const instanceData = new Float32Array(instances.length * 4);
  for (let i = 0; i < instances.length; i++) {
    instanceData[i * 4 + 0] = instances[i].x;
    instanceData[i * 4 + 1] = instances[i].y;
    instanceData[i * 4 + 2] = instances[i].z;
    instanceData[i * 4 + 3] = height;
  }
  
  gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.DYNAMIC_DRAW);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
  
  gl.enableVertexAttribArray(attribLocations.block.position);
  gl.vertexAttribPointer(attribLocations.block.position, 3, gl.FLOAT, false, 20, 0);
  
  gl.enableVertexAttribArray(attribLocations.block.texCoord);
  gl.vertexAttribPointer(attribLocations.block.texCoord, 2, gl.FLOAT, false, 20, 12);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
  gl.enableVertexAttribArray(attribLocations.block.instanceData);
  gl.vertexAttribPointer(attribLocations.block.instanceData, 4, gl.FLOAT, false, 16, 0);
  gl.vertexAttribDivisor(attribLocations.block.instanceData, 1);
  
  gl.uniform4f(uniformLocations.block.camera, camera.x, camera.y, camera.z, camera.angle);
  gl.uniform2f(uniformLocations.block.resolution, canvas.width, canvas.height);
  gl.uniform1i(uniformLocations.block.spriteIndex, tileType);
  gl.uniform1f(uniformLocations.block.spriteCount, tile_items_size);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, spriteTexture);
  gl.uniform1i(uniformLocations.block.spritesheet, 0);
  
  gl.drawArraysInstanced(gl.TRIANGLES, 0, 36, instances.length);
  
  gl.vertexAttribDivisor(attribLocations.block.instanceData, 0);
}

function drawBillboard(billboard) {
  gl.useProgram(billboardProgram);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, billboardBuffer);
  gl.enableVertexAttribArray(attribLocations.billboard.offset);
  gl.vertexAttribPointer(attribLocations.billboard.offset, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform2f(uniformLocations.billboard.screenPos, billboard.proj.x, billboard.proj.y);
  gl.uniform1f(uniformLocations.billboard.size, billboard.proj.size);
  gl.uniform1i(uniformLocations.billboard.spriteIndex, billboard.tile);
  gl.uniform1f(uniformLocations.billboard.spriteCount, tile_items_size);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, spriteTexture);
  gl.uniform1i(uniformLocations.billboard.spritesheet, 0);
  
  gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function projectToScreen(worldX, worldZ) {
  const dx = worldX - camera.x;
  const dy = worldZ - camera.y;

  const cosA = Math.cos(-camera.angle);
  const sinA = Math.sin(-camera.angle);

  const rotX = dx * cosA - dy * sinA;
  const rotY = dx * sinA + dy * cosA;

  const horizon = 0.3;
  const perspective = camera.z / (rotY - 0.001);

  const screenX = 0.5 + rotX * (1/(rotY - 0.001));
  const screenY = 1.0 - (horizon + perspective);

  return {
    visible: rotY > 0.1 && screenX >= 0 && screenX <= 1 && screenY >= 0 && screenY <= 1,
    x: screenX,
    y: screenY,
    size: 1.0 / rotY
  };
}

function isBillboard(n) { return billboard_tiles_set.has(n); }
function isBlock(n) { return block_tiles_set.has(n); }

// ======= CONTROLES =======
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function updateCamera() {
  const speed = 0.2;
  const rotSpeed = 0.05;

  if (keys['ArrowUp']) {
    camera.x -= Math.sin(camera.angle) * speed;
    camera.y += Math.cos(camera.angle) * speed;
  }
  if (keys['ArrowDown']) {
    camera.x += Math.sin(camera.angle) * speed;
    camera.y -= Math.cos(camera.angle) * speed;
  }
  if (keys['ArrowLeft']) camera.angle += rotSpeed;
  if (keys['ArrowRight']) camera.angle -= rotSpeed;
  if (keys['w']) camera.z += 0.1;
  if (keys['s']) camera.z = Math.max(0.1, camera.z - 0.1);
}

console.log("Motor 3D Mode7 con Cielo Simple - Flechas: mover | W/S: altura");
requestAnimationFrame(render);
</script>
</body>
</html>